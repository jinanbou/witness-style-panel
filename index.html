<script>
  const panelStates = panels.map(panel => {
    const canvas = panel.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const rect = panel.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    const state = {
      canvas, ctx,
      path: [],
      drawing: false,
      panel
    };

    canvas.addEventListener('pointerdown', e => {
      state.drawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      state.path = [{ x, y }];
    });

    canvas.addEventListener('pointermove', e => {
      if (!state.drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      state.path.push({ x, y });
      redraw(state);
    });

    canvas.addEventListener('pointerup', () => {
      state.drawing = false;
      if (state.path.length > 1) {
        panel.classList.add('drawn');
        showAnswerInputIfNeeded();
      }
    });

    function redraw(state) {
      const ctx = state.ctx;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (state.path.length < 2) return;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = 6;
      ctx.strokeStyle = '#3ad';
      ctx.beginPath();
      ctx.moveTo(state.path[0].x, state.path[0].y);
      for (let i = 1; i < state.path.length; i++) {
        ctx.lineTo(state.path[i].x, state.path[i].y);
      }
      ctx.stroke();
    }

    return state;
  });

  // 初期描画チェック
  showAnswerInputIfNeeded();
</script>
