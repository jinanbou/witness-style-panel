<script setup>
import { ref, onMounted } from 'vue'

const canvas = ref(null)
const canvas2 = ref(null)
const screen = ref(null)

const userInput = ref('')
const currentPanel = ref(0) // とりあえず最初のパネルのみ対応

function submitAnswer() {
  console.log(`Panel ${currentPanel.value + 1} の答え:`, userInput.value)
  // 今後: 答えチェックや進行処理をここに追加予定
  userInput.value = ''
}

const panels = []
const numPanels = 4

function createPanel(ctx, width, height, offsetX) {
  const panel = {
    ctx,
    canvas: ctx.canvas,
    path: [],
    drawing: false,
    guidePoints: []
  }
  // ガイド線用sin波データ作成
  const amp = height / 16
  const margin = 20
  const length = width - margin * 2
  for (let i = 0; i <= 100; i++) {
    const theta = (i / 100) * 2 * Math.PI
    const x = margin + (theta / (2 * Math.PI)) * length
    const y = height / 2 - amp * Math.sin(theta)
    panel.guidePoints.push({ x, y })
  }
  drawGuide(panel)
  return panel
}

function drawGuide(panel) {
  const ctx = panel.ctx
  ctx.clearRect(0, 0, panel.canvas.width, panel.canvas.height)
  const guideColor = '#aaa'
  ctx.strokeStyle = guideColor
  ctx.lineWidth = 2

  ctx.beginPath()
  const pts = panel.guidePoints
  ctx.moveTo(pts[0].x, pts[0].y)
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(pts[i].x, pts[i].y)
  }
  ctx.stroke()

  ctx.fillStyle = guideColor
  ctx.beginPath()
  ctx.arc(pts[0].x, pts[0].y, 6, 0, 2 * Math.PI)
  ctx.fill()
}

function drawLine(panel) {
  const ctx = panel.ctx
  ctx.clearRect(0, 0, panel.canvas.width, panel.canvas.height)
  if (panel.path.length < 2) return
  ctx.strokeStyle = 'black'
  ctx.lineWidth = 3
  ctx.beginPath()
  ctx.moveTo(panel.path[0].x, panel.path[0].y)
  for (let i = 1; i < panel.path.length; i++) {
    ctx.lineTo(panel.path[i].x, panel.path[i].y)
  }
  ctx.stroke()
}

onMounted(() => {
  const width = screen.value.clientWidth / 4
  const height = screen.value.clientHeight

  for (let i = 0; i < numPanels; i++) {
    const canvasEl = document.createElement('canvas')
    canvasEl.width = width
    canvasEl.height = height
    canvasEl.style.position = 'absolute'
    canvasEl.style.left = `${(width + 20) * i}px`
    canvasEl.style.top = '0'
    const ctx = canvasEl.getContext('2d')
    const panel = createPanel(ctx, width, height, (width + 20) * i)
    panels.push(panel)

    canvas.value.appendChild(canvasEl)

    canvasEl.addEventListener('pointerdown', (e) => {
      panel.drawing = true
      panel.path = []
      panel.path.push({ x: e.offsetX, y: e.offsetY })
    })
    canvasEl.addEventListener('pointermove', (e) => {
      if (!panel.drawing) return
      panel.path.push({ x: e.offsetX, y: e.offsetY })
      drawLine(panel)
    })
    canvasEl.addEventListener('pointerup', (e) => {
      panel.drawing = false
    })
  }
})
</script>

<template>
  <div ref="screen" class="relative w-full h-screen bg-white overflow-hidden">
    <div ref="canvas" class="absolute top-0 left-0 w-full h-full z-10"></div>
    <img
      ref="canvas2"
      src="https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d"
      class="absolute top-0 left-1/2 transform -translate-x-1/2 w-1/2 h-full object-cover z-0"
    />

    <!-- 答え入力欄 -->
    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-20 bg-white bg-opacity-80 rounded-xl px-4 py-2 shadow-md flex items-center space-x-2">
      <input
        v-model="userInput"
        @keydown.enter="submitAnswer"
        type="text"
        placeholder="答えを入力"
        class="border rounded px-2 py-1 w-48"
      />
      <button @click="submitAnswer" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded">
        決定
      </button>
    </div>
  </div>
</template>

<style scoped>
canvas {
  touch-action: none;
  position: absolute;
  z-index: 10;
}

img {
  position: absolute;
  z-index: 0;
}
</style>
